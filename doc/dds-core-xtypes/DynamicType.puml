@startuml
DynamicType -up-|> Instanceable

PrimitiveType -up-|> DynamicType
AggregationType -up-|> DynamicType
CollectionType -up-|> DynamicType

StructType -up-|> AggregationType
UnionType -up-|> AggregationType
EnumType -up-|> AggregationType

ArrayType -up-|> CollectionType
DynamicCollectionType -up-|> CollectionType

StringType -up-|> DynamicCollectionType
SequenceType -up-|> DynamicCollectionType
MapType -up-|> DynamicCollectionType

DynamicType *--> TypeKind

DynamicData *-right-> DynamicType
DynamicDataIterator *-right-> DynamicData

StructType --> StructMember
UnionType --> UnionMember
EnumType --> EnumMember

class Instanceable {
    friend DynamicData;
    + virtual size_t memory_size() const;
    # virtual size_t init() const;
    # virtual size_t copy() const;
    # virtual size_t move() const;
    # virtual size_t destroy() const;
    # virtual size_t compare() const;
}
class DynamicType {
    - std::string name;
    - TypeKind kind;
    # DynamicType(name, kind);
    + const std::string& name() const;
}

enum TypeKind {
}

class PrimitiveType {
    - PrimitiveType<T>(name, kind);
    + {static} primitive_type<T>();
}

class AggregationType<MemberImpl> {
    # std::map<std::string, MemberImpl> members;
    + size_t member_count() const;
    + const MemberImpl& member(const std::string& name);
}

class UnionMember {
    - std::string name;
    - std::unique_ptr<DynamicType> type;
    - std::vector<int32_t> labels;
    - int32_t id;
    + const std::string& name() const;
    + const DynamicType& dynamic_type() const;
    + const std::vector<int32_t>& labels() const;
    + int32_t get_id() const;
    + bool has_id() const;
    + bool is_key() const;
    + bool is_optional() const;
    + bool is_bitset() const;
    + UnionMember& key(bool value);
    + UnionMember& optional(bool value);
    + UnionMember& id(int32_t value);
    + UnionMember& label(int32_t value);
}

class EnumMember {
    - std::string name;
    - int32_t ordinal;
    + const std::string& name() const;
    + int32_t ordinal() const;
}

class StructMember {
    friend StructType;
    - std::string name;
    - std::unique_ptr<DynamicType> type;
    - int32_t id;
    - size_t offset;
    + size_t offset() const;
    + const std::string& name() const;
    + const DynamicType& dynamic_type() const;
    + int32_t get_id() const;
    + bool has_id() const;
    + bool is_key() const;
    + bool is_optional() const;
    + bool is_bitset() const;
    + StructMember& key(bool value);
    + StructMember& optional(bool value);
    + StructMember& id(int32_t value);
}

class StructType {
    - std::unique_ptr<DynamicType> parent;
    + const DynamicType& parent() const;
    + bool has_parent() const;
    + StructType& add_member(const StructMember& member);
}

class UnionType {
    - int32_t discriminator;
    + int32_t discriminator();
    + UnionType& add_member(const UnionMember& member);
}

class EnumType {
    + find_member_by_ordinal(int32_t ordinal);
    + UnionType& add_member(const EnumMember& member);
}

class CollectionType {
    - std::unique_ptr<DynamicType> content;
    + const DynamicType& content_type() const;
}

class ArrayType {
    - std::vector<uint32_t> dimensions;
    + const std::vector<uint32_t>& dimensions();
    + uint32_t dimension(int index) const;
}

class DynamicCollectionType {
    - uint32_t bounds;
    + uint32_t bounds() const;
    + void init(uint8_t* location) const;
    + void destroy(uint8_t* location) const;
}

class StringType {
}

class SequenceType {
}

class MapType {
    - std::unique_ptr<DynamicType> key;
    + const DynamicType& key_type() const;
}

class DynamicData {
    - DynamicType& type;
    - uint8_t* data;

    + const DynamicType& type() const;
    + const uint8_t* raw() const;
    + T& value() const;
    + T& value(const std::string& ) const;
}

class DynamicDataIterator {
    - DynamicData data;
    + const DynamicData& data() const;
    + const DynamicType& next_type() const;
    + T& next();
}

@enduml
